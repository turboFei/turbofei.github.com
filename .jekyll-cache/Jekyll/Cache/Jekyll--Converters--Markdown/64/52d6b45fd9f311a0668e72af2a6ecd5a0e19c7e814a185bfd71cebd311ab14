I"ƒ£<p>æœ¬æ–‡è½¬è‡ª<a href="https://github.com/jerryshao/jerryshao.github.com">Jerryshao Blog</a></p>

<h3 id="background">Background</h3>

<p>å‰æ®µæ—¶é—´çäº‹é¢‡å¤šï¼Œä¸€ç›´æ²¡æœ‰æ—¶é—´æ•´ç†è‡ªå·±çš„åšå®¢ï¼ŒSparkæºç åˆ†æå†™åˆ°ä¸€åŠä¹Ÿæç½®äº†ã€‚ä¹‹å‰ä»‹ç»äº†<a href="http://jerryshao.me/architecture/2013/04/21/Spark%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-scheduler%E6%A8%A1%E5%9D%97/"><strong>deploy</strong></a>å’Œ<a href="http://jerryshao.me/architecture/2013/04/21/Spark%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-scheduler%E6%A8%A1%E5%9D%97/"><strong>scheduler</strong></a>ä¸¤å¤§æ¨¡å—ï¼Œè¿™æ¬¡ä»‹ç»Sparkä¸­çš„å¦ä¸€å¤§æ¨¡å— - storageæ¨¡å—ã€‚</p>

<p>åœ¨å†™Sparkç¨‹åºçš„æ—¶å€™æˆ‘ä»¬å¸¸å¸¸å’Œ<strong>RDD</strong> ( <em>Resilient Distributed Dataset</em> ) æ‰“äº¤é“ï¼Œé€šè¿‡RDDä¸ºæˆ‘ä»¬æä¾›çš„å„ç§transformationå’Œactionæ¥å£å®ç°æˆ‘ä»¬çš„åº”ç”¨ï¼ŒRDDçš„å¼•å…¥æé«˜äº†æŠ½è±¡å±‚æ¬¡ï¼Œåœ¨æ¥å£å’Œå®ç°ä¸Šè¿›è¡Œæœ‰æ•ˆåœ°éš”ç¦»ï¼Œä½¿ç”¨æˆ·æ— éœ€å…³å¿ƒåº•å±‚çš„å®ç°ã€‚ä½†æ˜¯RDDæä¾›ç»™æˆ‘ä»¬çš„ä»…ä»…æ˜¯ä¸€ä¸ªâ€œ<strong>å½¢</strong>â€, æˆ‘ä»¬æ‰€æ“ä½œçš„æ•°æ®ç©¶ç«Ÿæ”¾åœ¨å“ªé‡Œï¼Œå¦‚ä½•å­˜å–ï¼Ÿå®ƒçš„â€œ<strong>ä½“</strong>â€æ˜¯æ€ä¹ˆæ ·çš„ï¼Ÿè¿™æ˜¯ç”±storageæ¨¡å—æ¥å®ç°å’Œç®¡ç†çš„ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°±è¦å‰–æä¸€ä¸‹storageæ¨¡å—ã€‚</p>

<h2 id="storageæ¨¡å—æ•´ä½“æ¶æ„">Storageæ¨¡å—æ•´ä½“æ¶æ„</h2>

<p>Storageæ¨¡å—ä¸»è¦åˆ†ä¸ºä¸¤å±‚ï¼š</p>

<ol>
  <li>é€šä¿¡å±‚ï¼šstorageæ¨¡å—é‡‡ç”¨çš„æ˜¯master-slaveç»“æ„æ¥å®ç°é€šä¿¡å±‚ï¼Œmasterå’Œslaveä¹‹é—´ä¼ è¾“æ§åˆ¶ä¿¡æ¯ã€çŠ¶æ€ä¿¡æ¯ï¼Œè¿™äº›éƒ½æ˜¯é€šè¿‡é€šä¿¡å±‚æ¥å®ç°çš„ã€‚</li>
  <li>å­˜å‚¨å±‚ï¼šstorageæ¨¡å—éœ€è¦æŠŠæ•°æ®å­˜å‚¨åˆ°diskæˆ–æ˜¯memoryä¸Šé¢ï¼Œæœ‰å¯èƒ½è¿˜éœ€replicateåˆ°è¿œç«¯ï¼Œè¿™éƒ½æ˜¯ç”±å­˜å‚¨å±‚æ¥å®ç°å’Œæä¾›ç›¸åº”æ¥å£ã€‚</li>
</ol>

<p>è€Œå…¶ä»–æ¨¡å—è‹¥è¦å’Œstorageæ¨¡å—è¿›è¡Œäº¤äº’ï¼Œstorageæ¨¡å—æä¾›äº†ç»Ÿä¸€çš„æ“ä½œç±»<code class="language-plaintext highlighter-rouge">BlockManager</code>ï¼Œå¤–éƒ¨ç±»ä¸storageæ¨¡å—æ‰“äº¤é“éƒ½éœ€è¦é€šè¿‡è°ƒç”¨<code class="language-plaintext highlighter-rouge">BlockManager</code>ç›¸åº”æ¥å£æ¥å®ç°ã€‚</p>

<h2 id="storageæ¨¡å—é€šä¿¡å±‚">Storageæ¨¡å—é€šä¿¡å±‚</h2>

<p>é¦–å…ˆæ¥çœ‹ä¸€ä¸‹é€šä¿¡å±‚çš„UMLç±»å›¾:</p>

<p><img src="/img/2013-10-08-storage/communication_layer.png" alt="communication layer class chart" width="640" /></p>

<p>å…¶æ¬¡æˆ‘ä»¬æ¥çœ‹çœ‹å„ä¸ªç±»åœ¨masterå’Œslaveä¸Šæ‰€æ‰®æ¼”çš„ä¸åŒè§’è‰²ï¼š</p>

<p><img src="/img/2013-10-08-storage/communication_character.png" alt="communication character class chart" width="640" /></p>

<p>å¯¹äºmasterå’Œslaveï¼Œ<code class="language-plaintext highlighter-rouge">BlockManager</code>çš„åˆ›å»ºæœ‰æ‰€ä¸åŒï¼š</p>

<ul>
  <li>
    <p>Master (client driver)</p>

    <p><code class="language-plaintext highlighter-rouge">BlockManagerMaster</code>æ‹¥æœ‰<code class="language-plaintext highlighter-rouge">BlockManagerMasterActor</code>çš„<em>actor</em>å’Œæ‰€æœ‰<code class="language-plaintext highlighter-rouge">BlockManagerSlaveActor</code>çš„<em>ref</em>ã€‚</p>
  </li>
  <li>
    <p>Slave (executor)</p>

    <p>å¯¹äºslaveï¼Œ<code class="language-plaintext highlighter-rouge">BlockManagerMaster</code>åˆ™æ‹¥æœ‰<code class="language-plaintext highlighter-rouge">BlockManagerMasterActor</code>çš„<em>ref</em>å’Œè‡ªèº«<code class="language-plaintext highlighter-rouge">BlockManagerSlaveActor</code>çš„<em>actor</em>ã€‚</p>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">BlockManagerMasterActor</code>åœ¨<em>ref</em>å’Œ<em>actor</em>ä¹‹é—´è¿›è¡Œé€šä¿¡ï¼›<code class="language-plaintext highlighter-rouge">BlockManagerSlaveActor</code>åœ¨<em>ref</em>å’Œ<em>actor</em>ä¹‹é—´é€šä¿¡ã€‚</p>

<blockquote>
  <p><em>actor</em>å’Œ<em>ref</em>:</p>

  <p><em>actor</em>å’Œ<em>ref</em>æ˜¯<a href="http://akka.io/"><strong>Akka</strong></a>ä¸­çš„ä¸¤ä¸ªä¸åŒçš„actor referenceï¼Œåˆ†åˆ«ç”±<code class="language-plaintext highlighter-rouge">actorOf</code>å’Œ<code class="language-plaintext highlighter-rouge">actorFor</code>æ‰€åˆ›å»ºã€‚<em>actor</em>ç±»ä¼¼äºç½‘ç»œæœåŠ¡ä¸­çš„serverç«¯ï¼Œå®ƒä¿å­˜æ‰€æœ‰çš„çŠ¶æ€ä¿¡æ¯ï¼Œæ¥æ”¶clientç«¯çš„è¯·æ±‚æ‰§è¡Œå¹¶è¿”å›ç»™å®¢æˆ·ç«¯ï¼›<em>ref</em>ç±»ä¼¼äºç½‘ç»œæœåŠ¡ä¸­çš„clientç«¯ï¼Œé€šè¿‡å‘serverç«¯å‘èµ·è¯·æ±‚è·å–ç»“æœã€‚</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">BlockManager</code> wrapäº†<code class="language-plaintext highlighter-rouge">BlockManagerMaster</code>ï¼Œé€šè¿‡<code class="language-plaintext highlighter-rouge">BlockManagerMaster</code>è¿›è¡Œé€šä¿¡ã€‚Sparkä¼šåœ¨client driverå’Œexecutorç«¯åˆ›å»ºå„è‡ªçš„<code class="language-plaintext highlighter-rouge">BlockManager</code>ï¼Œé€šè¿‡<code class="language-plaintext highlighter-rouge">BlockManager</code>å¯¹storageæ¨¡å—è¿›è¡Œæ“ä½œã€‚</p>

<p><code class="language-plaintext highlighter-rouge">BlockManager</code>å¯¹è±¡åœ¨<code class="language-plaintext highlighter-rouge">SparkEnv</code>ä¸­è¢«åˆ›å»ºï¼Œåˆ›å»ºçš„è¿‡ç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def registerOrLookup(name: String, newActor: =&gt; Actor): ActorRef = {
  if (isDriver) {
    logInfo("Registering " + name)
    actorSystem.actorOf(Props(newActor), name = name)
  } else {
    val driverHost: String = System.getProperty("spark.driver.host", "localhost")
    val driverPort: Int = System.getProperty("spark.driver.port", "7077").toInt
    Utils.checkHost(driverHost, "Expected hostname")
    val url = "akka://spark@%s:%s/user/%s".format(driverHost, driverPort, name)
    logInfo("Connecting to " + name + ": " + url)
    actorSystem.actorFor(url)
  }
}

val blockManagerMaster = new BlockManagerMaster(registerOrLookup(
  "BlockManagerMaster",
  new BlockManagerMasterActor(isLocal)))
val blockManager = new BlockManager(executorId, actorSystem, blockManagerMaster, serializer)
</code></pre></div></div>

<p>å¯ä»¥çœ‹åˆ°å¯¹äºclient driverå’Œexecutorï¼ŒSparkåˆ†åˆ«åˆ›å»ºäº†<code class="language-plaintext highlighter-rouge">BlockManagerMasterActor</code> <em>actor</em>å’Œ<em>ref</em>ï¼Œå¹¶è¢«wrapåˆ°<code class="language-plaintext highlighter-rouge">BlockManager</code>ä¸­ã€‚</p>

<h3 id="é€šä¿¡å±‚ä¼ é€’çš„æ¶ˆæ¯">é€šä¿¡å±‚ä¼ é€’çš„æ¶ˆæ¯</h3>

<ul>
  <li>
    <p><strong>BlockManagerMasterActor</strong></p>

    <ul>
      <li>
        <p><strong>executor</strong>  to <strong>client driver</strong></p>

        <p>RegisterBlockManager (executoråˆ›å»ºBlockManagerä»¥åå‘client driverå‘é€è¯·æ±‚æ³¨å†Œè‡ªèº«)
  HeartBeat
  UpdateBlockInfo (æ›´æ–°blockä¿¡æ¯)
  GetPeers (è¯·æ±‚è·å¾—å…¶ä»–BlockManagerçš„id)
  GetLocations (è·å–blockæ‰€åœ¨çš„BlockManagerçš„id)
  GetLocationsMultipleBlockIds (è·å–ä¸€ç»„blockæ‰€åœ¨çš„BlockManager id)</p>
      </li>
      <li>
        <p><strong>client driver</strong>  to <strong>client driver</strong></p>

        <p>GetLocations (è·å–blockæ‰€åœ¨çš„BlockManagerçš„id)
  GetLocationsMultipleBlockIds (è·å–ä¸€ç»„blockæ‰€åœ¨çš„BlockManager id)
  RemoveExecutor (åˆ é™¤æ‰€ä¿å­˜çš„å·²ç»æ­»äº¡çš„executorä¸Šçš„BlockManager)
  StopBlockManagerMaster (åœæ­¢client driverä¸Šçš„BlockManagerMasterActor)</p>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>æœ‰äº›æ¶ˆæ¯ä¾‹å¦‚<code class="language-plaintext highlighter-rouge">GetLocations</code>åœ¨executorç«¯å’Œclient driverç«¯éƒ½ä¼šå‘<em>actor</em>è¯·æ±‚ï¼Œè€Œå…¶ä»–çš„æ¶ˆæ¯æ¯”å¦‚<code class="language-plaintext highlighter-rouge">RegisterBlockManager</code>åªä¼šç”±executorç«¯çš„<em>ref</em>å‘client driverç«¯çš„<em>actor</em>å‘é€ï¼Œäºæ­¤åŒæ—¶ä¾‹å¦‚<code class="language-plaintext highlighter-rouge">RemoveExecutor</code>åˆ™åªä¼šç”±client driverç«¯çš„<em>ref</em>å‘client driverç«¯çš„<em>actor</em>å‘é€ã€‚</p>

  <p>å…·ä½“æ¶ˆæ¯æ˜¯ä»å“ªé‡Œå‘é€ï¼Œå“ªé‡Œæ¥æ”¶å’Œå¤„ç†è¯·çœ‹ä»£ç ç»†èŠ‚ï¼Œåœ¨è¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ã€‚</p>
</blockquote>

<ul>
  <li>
    <p><strong>BlockManagerSlaveActor</strong></p>

    <ul>
      <li>
        <p><strong>client driver</strong> to <strong>executor</strong></p>

        <p>RemoveBlock (åˆ é™¤block)
  RemoveRdd (åˆ é™¤RDD)</p>
      </li>
    </ul>
  </li>
</ul>

<p>é€šä¿¡å±‚ä¸­æ¶‰åŠè®¸å¤šæ§åˆ¶æ¶ˆæ¯å’ŒçŠ¶æ€æ¶ˆæ¯çš„ä¼ é€’ä»¥åŠå¤„ç†ï¼Œè¿™äº›ç»†èŠ‚å¯ä»¥ç›´æ¥æŸ¥çœ‹æºç ï¼Œè¿™é‡Œå°±ä¸åœ¨ä¸€ä¸€ç½—åˆ—ã€‚ä¸‹é¢å°±åªç®€å•ä»‹ç»ä¸€ä¸‹exeuctorç«¯çš„<code class="language-plaintext highlighter-rouge">BlockManager</code>æ˜¯å¦‚ä½•å¯åŠ¨ä»¥åŠå‘client driverå‘é€æ³¨å†Œè¯·æ±‚å®Œæˆæ³¨å†Œã€‚</p>

<h3 id="register-blockmanager">Register BlockManager</h3>

<p>å‰é¢å·²ç»ä»‹ç»äº†<code class="language-plaintext highlighter-rouge">BlockManager</code>å¯¹è±¡æ˜¯å¦‚ä½•è¢«åˆ›å»ºå‡ºæ¥çš„ï¼Œå½“<code class="language-plaintext highlighter-rouge">BlockManager</code>è¢«åˆ›å»ºå‡ºæ¥ä»¥åéœ€è¦å‘client driveræ³¨å†Œè‡ªå·±ï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹è¿™ä¸ªæµç¨‹ï¼š</p>

<p>é¦–å…ˆ<code class="language-plaintext highlighter-rouge">BlockManager</code>ä¼šè°ƒç”¨<code class="language-plaintext highlighter-rouge">initialize()</code>åˆå§‹åŒ–è‡ªå·±</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private def initialize() {
  master.registerBlockManager(blockManagerId, maxMemory, slaveActor)
  ...
  if (!BlockManager.getDisableHeartBeatsForTesting) {
    heartBeatTask = actorSystem.scheduler.schedule(0.seconds, heartBeatFrequency.milliseconds) {
      heartBeat()
    }
  }
}
</code></pre></div></div>

<p>åœ¨<code class="language-plaintext highlighter-rouge">initialized()</code>å‡½æ•°ä¸­é¦–å…ˆè°ƒç”¨<code class="language-plaintext highlighter-rouge">BlockManagerMaster</code>å‘client driveræ³¨å†Œè‡ªå·±ï¼ŒåŒæ—¶è®¾ç½®heartbeatå®šæ—¶å™¨ï¼Œå®šæ—¶å‘é€heartbeatæŠ¥æ–‡ã€‚å¯ä»¥çœ‹åˆ°åœ¨æ³¨å†Œè‡ªèº«çš„æ—¶å€™å‘client driverä¼ é€’äº†è‡ªèº«çš„<code class="language-plaintext highlighter-rouge">slaveActor</code>ï¼Œclient driveræ”¶åˆ°<code class="language-plaintext highlighter-rouge">slaveActor</code>ä»¥åä¼šå°†å…¶ä¸ä¹‹å¯¹åº”çš„<code class="language-plaintext highlighter-rouge">BlockManagerInfo</code>å­˜å‚¨åˆ°hash mapä¸­ï¼Œä»¥ä¾¿åç»­é€šè¿‡<code class="language-plaintext highlighter-rouge">slaveActor</code>å‘executorå‘é€å‘½ä»¤ã€‚</p>

<p><code class="language-plaintext highlighter-rouge">BlockManagerMaster</code>ä¼šå°†æ³¨å†Œè¯·æ±‚åŒ…è£…æˆ<code class="language-plaintext highlighter-rouge">RegisterBlockManager</code>æŠ¥æ–‡å‘é€ç»™client driverçš„<code class="language-plaintext highlighter-rouge">BlockManagerMasterActor</code>ï¼Œ<code class="language-plaintext highlighter-rouge">BlockManagerMasterActor</code>è°ƒç”¨<code class="language-plaintext highlighter-rouge">register()</code>å‡½æ•°æ³¨å†Œ<code class="language-plaintext highlighter-rouge">BlockManager</code>ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private def register(id: BlockManagerId, maxMemSize: Long, slaveActor: ActorRef) {
  if (id.executorId == "&lt;driver&gt;" &amp;&amp; !isLocal) {
    // Got a register message from the master node; don't register it
  } else if (!blockManagerInfo.contains(id)) {
    blockManagerIdByExecutor.get(id.executorId) match {
      case Some(manager) =&gt;
        // A block manager of the same executor already exists.
        // This should never happen. Let's just quit.
        logError("Got two different block manager registrations on " + id.executorId)
        System.exit(1)
      case None =&gt;
        blockManagerIdByExecutor(id.executorId) = id
    }
    blockManagerInfo(id) = new BlockManagerMasterActor.BlockManagerInfo(
      id, System.currentTimeMillis(), maxMemSize, slaveActor)
  }
}
</code></pre></div></div>

<p>éœ€è¦æ³¨æ„çš„æ˜¯åœ¨client driverç«¯ä¹Ÿä¼šæ‰§è¡Œä¸Šè¿°è¿‡ç¨‹ï¼Œåªæ˜¯åœ¨æœ€åæ³¨å†Œçš„æ—¶å€™å¦‚æœåˆ¤æ–­æ˜¯<code class="language-plaintext highlighter-rouge">"&lt;driver&gt;"</code>å°±ä¸è¿›è¡Œä»»ä½•æ“ä½œã€‚å¯ä»¥çœ‹åˆ°å¯¹åº”çš„<code class="language-plaintext highlighter-rouge">BlockManagerInfo</code>å¯¹è±¡è¢«åˆ›å»ºå¹¶ä¿å­˜åœ¨hash mapä¸­ã€‚</p>

<h2 id="storageæ¨¡å—å­˜å‚¨å±‚">Storageæ¨¡å—å­˜å‚¨å±‚</h2>

<p>åœ¨RDDå±‚é¢ä¸Šæˆ‘ä»¬äº†è§£åˆ°RDDæ˜¯ç”±ä¸åŒçš„partitionç»„æˆçš„ï¼Œæˆ‘ä»¬æ‰€è¿›è¡Œçš„transformationå’Œactionæ˜¯åœ¨partitionä¸Šé¢è¿›è¡Œçš„ï¼›è€Œåœ¨storageæ¨¡å—å†…éƒ¨ï¼ŒRDDåˆè¢«è§†ä¸ºç”±ä¸åŒçš„blockç»„æˆï¼Œå¯¹äºRDDçš„å­˜å–æ˜¯ä»¥blockä¸ºå•ä½è¿›è¡Œçš„ï¼Œæœ¬è´¨ä¸Špartitionå’Œblockæ˜¯ç­‰ä»·çš„ï¼Œåªæ˜¯çœ‹å¾…çš„è§’åº¦ä¸åŒã€‚åœ¨Spark storageæ¨¡å—ä¸­ä¸­å­˜å–æ•°æ®çš„æœ€å°å•ä½æ˜¯blockï¼Œæ‰€æœ‰çš„æ“ä½œéƒ½æ˜¯ä»¥blockä¸ºå•ä½è¿›è¡Œçš„ã€‚</p>

<p>é¦–å…ˆæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹å­˜å‚¨å±‚çš„UMLç±»å›¾:</p>

<p><img src="/img/2013-10-08-storage/storage_layer.png" alt="storage layer class chart" width="640" /></p>

<p><code class="language-plaintext highlighter-rouge">BlockManager</code>å¯¹è±¡è¢«åˆ›å»ºçš„æ—¶å€™ä¼šåˆ›å»ºå‡º<code class="language-plaintext highlighter-rouge">MemoryStore</code>å’Œ<code class="language-plaintext highlighter-rouge">DiskStore</code>å¯¹è±¡ç”¨ä»¥å­˜å–blockï¼ŒåŒæ—¶åœ¨<code class="language-plaintext highlighter-rouge">initialize()</code>å‡½æ•°ä¸­åˆ›å»º<code class="language-plaintext highlighter-rouge">BlockManagerWorker</code>å¯¹è±¡ç”¨ä»¥ç›‘å¬è¿œç¨‹çš„blockå­˜å–è¯·æ±‚æ¥è¿›è¡Œç›¸åº”å¤„ç†ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private[storage] val memoryStore: BlockStore = new MemoryStore(this, maxMemory)
private[storage] val diskStore: DiskStore =
  new DiskStore(this, System.getProperty("spark.local.dir", System.getProperty("java.io.tmpdir")))

private def initialize() {
  ...
  BlockManagerWorker.startBlockManagerWorker(this)
  ...
}
</code></pre></div></div>

<p>ä¸‹é¢å°±å…·ä½“ä»‹ç»ä¸€ä¸‹å¯¹äº<code class="language-plaintext highlighter-rouge">DiskStore</code>å’Œ<code class="language-plaintext highlighter-rouge">MemoryStore</code>ï¼Œblockçš„å­˜å–æ“ä½œæ˜¯æ€æ ·è¿›è¡Œçš„ã€‚</p>

<h3 id="diskstoreå¦‚ä½•å­˜å–block">DiskStoreå¦‚ä½•å­˜å–block</h3>

<p><code class="language-plaintext highlighter-rouge">DiskStore</code>å¯ä»¥é…ç½®å¤šä¸ªfolderï¼ŒSparkä¼šåœ¨ä¸åŒçš„folderä¸‹é¢åˆ›å»ºSparkæ–‡ä»¶å¤¹ï¼Œæ–‡ä»¶å¤¹çš„å‘½åæ–¹å¼ä¸º(spark-local-yyyyMMddHHmmss-xxxx, xxxxæ˜¯ä¸€ä¸ªéšæœºæ•°)ï¼Œæ‰€æœ‰çš„blockéƒ½ä¼šå­˜å‚¨åœ¨æ‰€åˆ›å»ºçš„folderé‡Œé¢ã€‚<code class="language-plaintext highlighter-rouge">DiskStore</code>ä¼šåœ¨å¯¹è±¡è¢«åˆ›å»ºæ—¶è°ƒç”¨<code class="language-plaintext highlighter-rouge">createLocalDirs()</code>æ¥åˆ›å»ºæ–‡ä»¶å¤¹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private def createLocalDirs(): Array[File] = {
  logDebug("Creating local directories at root dirs '" + rootDirs + "'")
  val dateFormat = new SimpleDateFormat("yyyyMMddHHmmss")
  rootDirs.split(",").map { rootDir =&gt;
    var foundLocalDir = false
    var localDir: File = null
    var localDirId: String = null
    var tries = 0
    val rand = new Random()
    while (!foundLocalDir &amp;&amp; tries &lt; MAX_DIR_CREATION_ATTEMPTS) {
      tries += 1
      try {
        localDirId = "%s-%04x".format(dateFormat.format(new Date), rand.nextInt(65536))
        localDir = new File(rootDir, "spark-local-" + localDirId)
        if (!localDir.exists) {
          foundLocalDir = localDir.mkdirs()
        }
      } catch {
        case e: Exception =&gt;
          logWarning("Attempt " + tries + " to create local dir " + localDir + " failed", e)
      }
    }
    if (!foundLocalDir) {
      logError("Failed " + MAX_DIR_CREATION_ATTEMPTS +
        " attempts to create local dir in " + rootDir)
      System.exit(ExecutorExitCode.DISK_STORE_FAILED_TO_CREATE_DIR)
    }
    logInfo("Created local directory at " + localDir)
    localDir
  }
}
</code></pre></div></div>

<p>åœ¨<code class="language-plaintext highlighter-rouge">DiskStore</code>é‡Œé¢ï¼Œæ¯ä¸€ä¸ªblockéƒ½è¢«å­˜å‚¨ä¸ºä¸€ä¸ªfileï¼Œé€šè¿‡è®¡ç®—block idçš„hashå€¼å°†blockæ˜ å°„åˆ°æ–‡ä»¶ä¸­ï¼Œblock idä¸æ–‡ä»¶è·¯å¾„çš„æ˜ å°„å…³ç³»å¦‚ä¸‹æ‰€ç¤ºï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private def getFile(blockId: String): File = {
  logDebug("Getting file for block " + blockId)

  // Figure out which local directory it hashes to, and which subdirectory in that
  val hash = Utils.nonNegativeHash(blockId)
  val dirId = hash % localDirs.length
  val subDirId = (hash / localDirs.length) % subDirsPerLocalDir

  // Create the subdirectory if it doesn't already exist
  var subDir = subDirs(dirId)(subDirId)
  if (subDir == null) {
    subDir = subDirs(dirId).synchronized {
      val old = subDirs(dirId)(subDirId)
      if (old != null) {
        old
      } else {
        val newDir = new File(localDirs(dirId), "%02x".format(subDirId))
        newDir.mkdir()
        subDirs(dirId)(subDirId) = newDir
        newDir
      }
    }
  }

  new File(subDir, blockId)
}
</code></pre></div></div>

<p>æ ¹æ®block idè®¡ç®—å‡ºhashå€¼ï¼Œå°†hashå–æ¨¡è·å¾—<code class="language-plaintext highlighter-rouge">dirId</code>å’Œ<code class="language-plaintext highlighter-rouge">subDirId</code>ï¼Œåœ¨<code class="language-plaintext highlighter-rouge">subDirs</code>ä¸­æ‰¾å‡ºç›¸åº”çš„<code class="language-plaintext highlighter-rouge">subDir</code>ï¼Œè‹¥æ²¡æœ‰åˆ™æ–°å»ºä¸€ä¸ª<code class="language-plaintext highlighter-rouge">subDir</code>ï¼Œæœ€åä»¥<code class="language-plaintext highlighter-rouge">subDir</code>ä¸ºè·¯å¾„ã€block idä¸ºæ–‡ä»¶ååˆ›å»ºfile handlerï¼Œ<code class="language-plaintext highlighter-rouge">DiskStore</code>ä½¿ç”¨æ­¤file handlerå°†blockå†™å…¥æ–‡ä»¶å†…ï¼Œä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>override def putBytes(blockId: String, _bytes: ByteBuffer, level: StorageLevel) {
  // So that we do not modify the input offsets !
  // duplicate does not copy buffer, so inexpensive
  val bytes = _bytes.duplicate()
  logDebug("Attempting to put block " + blockId)
  val startTime = System.currentTimeMillis
  val file = createFile(blockId)
  val channel = new RandomAccessFile(file, "rw").getChannel()
  while (bytes.remaining &gt; 0) {
    channel.write(bytes)
  }
  channel.close()
  val finishTime = System.currentTimeMillis
  logDebug("Block %s stored as %s file on disk in %d ms".format(
    blockId, Utils.bytesToString(bytes.limit), (finishTime - startTime)))
}
</code></pre></div></div>

<p>è€Œè·å–blockåˆ™éå¸¸ç®€å•ï¼Œæ‰¾åˆ°ç›¸åº”çš„æ–‡ä»¶å¹¶è¯»å–å‡ºæ¥å³å¯ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>override def getBytes(blockId: String): Option[ByteBuffer] = {
  val file = getFile(blockId)
  val bytes = getFileBytes(file)
  Some(bytes)
}
</code></pre></div></div>

<p>å› æ­¤åœ¨<code class="language-plaintext highlighter-rouge">DiskStore</code>ä¸­å­˜å–blocké¦–å…ˆæ˜¯è¦å°†block idæ˜ å°„æˆç›¸åº”çš„æ–‡ä»¶è·¯å¾„ï¼Œæ¥ç€å­˜å–æ–‡ä»¶å°±å¯ä»¥äº†ã€‚</p>

<h3 id="memorystoreå¦‚ä½•å­˜å–block">MemoryStoreå¦‚ä½•å­˜å–block</h3>

<p>ç›¸å¯¹äº<code class="language-plaintext highlighter-rouge">DiskStore</code>éœ€è¦æ ¹æ®block id hashè®¡ç®—å‡ºæ–‡ä»¶è·¯å¾„å¹¶å°†blockå­˜æ”¾åˆ°å¯¹åº”çš„æ–‡ä»¶é‡Œé¢ï¼Œ<code class="language-plaintext highlighter-rouge">MemoryStore</code>ç®¡ç†blockå°±æ˜¾å¾—éå¸¸ç®€å•ï¼š<code class="language-plaintext highlighter-rouge">MemoryStore</code>å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªhash mapæ¥ç®¡ç†æ‰€æœ‰çš„blockï¼Œä»¥block idä¸ºkeyå°†blockå­˜æ”¾åˆ°hash mapä¸­ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>case class Entry(value: Any, size: Long, deserialized: Boolean)

private val entries = new LinkedHashMap[String, Entry](32, 0.75f, true)
</code></pre></div></div>

<p>åœ¨<code class="language-plaintext highlighter-rouge">MemoryStore</code>ä¸­å­˜æ”¾blockå¿…é¡»ç¡®ä¿å†…å­˜è¶³å¤Ÿå®¹çº³ä¸‹è¯¥blockï¼Œè‹¥å†…å­˜ä¸è¶³åˆ™ä¼šå°†blockå†™åˆ°æ–‡ä»¶ä¸­ï¼Œå…·ä½“çš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>override def putBytes(blockId: String, _bytes: ByteBuffer, level: StorageLevel) {
  // Work on a duplicate - since the original input might be used elsewhere.
  val bytes = _bytes.duplicate()
  bytes.rewind()
  if (level.deserialized) {
    val values = blockManager.dataDeserialize(blockId, bytes)
    val elements = new ArrayBuffer[Any]
    elements ++= values
    val sizeEstimate = SizeEstimator.estimate(elements.asInstanceOf[AnyRef])
    tryToPut(blockId, elements, sizeEstimate, true)
  } else {
    tryToPut(blockId, bytes, bytes.limit, false)
  }
}
</code></pre></div></div>

<p>åœ¨<code class="language-plaintext highlighter-rouge">tryToPut()</code>ä¸­ï¼Œé¦–å…ˆè°ƒç”¨<code class="language-plaintext highlighter-rouge">ensureFreeSpace()</code>ç¡®ä¿ç©ºé—²å†…å­˜æ˜¯å¦è¶³ä»¥å®¹çº³blockï¼Œè‹¥å¯ä»¥åˆ™å°†è¯¥blockæ”¾å…¥hash mapä¸­è¿›è¡Œç®¡ç†ï¼›è‹¥ä¸è¶³ä»¥å®¹çº³åˆ™é€šè¿‡è°ƒç”¨<code class="language-plaintext highlighter-rouge">dropFromMemory()</code>å°†blockå†™å…¥æ–‡ä»¶ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private def tryToPut(blockId: String, value: Any, size: Long, deserialized: Boolean): Boolean = {
  // TODO: Its possible to optimize the locking by locking entries only when selecting blocks
  // to be dropped. Once the to-be-dropped blocks have been selected, and lock on entries has been
  // released, it must be ensured that those to-be-dropped blocks are not double counted for
  // freeing up more space for another block that needs to be put. Only then the actually dropping
  // of blocks (and writing to disk if necessary) can proceed in parallel.
  putLock.synchronized {
    if (ensureFreeSpace(blockId, size)) {
      val entry = new Entry(value, size, deserialized)
      entries.synchronized {
        entries.put(blockId, entry)
        currentMemory += size
      }
      if (deserialized) {
        logInfo("Block %s stored as values to memory (estimated size %s, free %s)".format(
          blockId, Utils.bytesToString(size), Utils.bytesToString(freeMemory)))
      } else {
        logInfo("Block %s stored as bytes to memory (size %s, free %s)".format(
          blockId, Utils.bytesToString(size), Utils.bytesToString(freeMemory)))
      }
      true
    } else {
      // Tell the block manager that we couldn't put it in memory so that it can drop it to
      // disk if the block allows disk storage.
      val data = if (deserialized) {
        Left(value.asInstanceOf[ArrayBuffer[Any]])
      } else {
        Right(value.asInstanceOf[ByteBuffer].duplicate())
      }
      blockManager.dropFromMemory(blockId, data)
      false
    }
  }
}
</code></pre></div></div>

<p>è€Œä»<code class="language-plaintext highlighter-rouge">MemoryStore</code>ä¸­å–å¾—blockåˆ™éå¸¸ç®€å•ï¼Œåªéœ€ä»hash mapä¸­å–å‡ºblock idå¯¹åº”çš„valueå³å¯ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>override def getValues(blockId: String): Option[Iterator[Any]] = {
  val entry = entries.synchronized {
    entries.get(blockId)
  }
  if (entry == null) {
    None
  } else if (entry.deserialized) {
    Some(entry.value.asInstanceOf[ArrayBuffer[Any]].iterator)
  } else {
    val buffer = entry.value.asInstanceOf[ByteBuffer].duplicate() // Doesn't actually copy data
    Some(blockManager.dataDeserialize(blockId, buffer))
  }
}
</code></pre></div></div>

<h3 id="put-or-get-block-through-blockmanager">Put or Get block through BlockManager</h3>

<p>ä¸Šé¢ä»‹ç»äº†<code class="language-plaintext highlighter-rouge">DiskStore</code>å’Œ<code class="language-plaintext highlighter-rouge">MemoryStore</code>å¯¹äºblockçš„å­˜å–æ“ä½œï¼Œé‚£ä¹ˆæˆ‘ä»¬æ˜¯è¦ç›´æ¥ä¸å®ƒä»¬äº¤äº’å­˜å–æ•°æ®å—ï¼Œè¿˜æ˜¯å°è£…äº†æ›´æŠ½è±¡çš„æ¥å£ä½¿æˆ‘ä»¬æ— éœ€å…³å¿ƒåº•å±‚ï¼Ÿ</p>

<p><code class="language-plaintext highlighter-rouge">BlockManager</code>ä¸ºæˆ‘ä»¬æä¾›äº†<code class="language-plaintext highlighter-rouge">put()</code>å’Œ<code class="language-plaintext highlighter-rouge">get()</code>å‡½æ•°ï¼Œç”¨æˆ·å¯ä»¥ä½¿ç”¨è¿™ä¸¤ä¸ªå‡½æ•°å¯¹blockè¿›è¡Œå­˜å–è€Œæ— éœ€å…³å¿ƒåº•å±‚å®ç°ã€‚</p>

<p>é¦–å…ˆæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹<code class="language-plaintext highlighter-rouge">put()</code>å‡½æ•°çš„å®ç°ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def put(blockId: String, values: ArrayBuffer[Any], level: StorageLevel,
  tellMaster: Boolean = true) : Long = {

  ...

  // Remember the block's storage level so that we can correctly drop it to disk if it needs
  // to be dropped right after it got put into memory. Note, however, that other threads will
  // not be able to get() this block until we call markReady on its BlockInfo.
  val myInfo = {
    val tinfo = new BlockInfo(level, tellMaster)
    // Do atomically !
    val oldBlockOpt = blockInfo.putIfAbsent(blockId, tinfo)

    if (oldBlockOpt.isDefined) {
      if (oldBlockOpt.get.waitForReady()) {
        logWarning("Block " + blockId + " already exists on this machine; not re-adding it")
        return oldBlockOpt.get.size
      }

      // TODO: So the block info exists - but previous attempt to load it (?) failed. What do we do now ? Retry on it ?
      oldBlockOpt.get
    } else {
      tinfo
    }
  }

  val startTimeMs = System.currentTimeMillis

  // If we need to replicate the data, we'll want access to the values, but because our
  // put will read the whole iterator, there will be no values left. For the case where
  // the put serializes data, we'll remember the bytes, above; but for the case where it
  // doesn't, such as deserialized storage, let's rely on the put returning an Iterator.
  var valuesAfterPut: Iterator[Any] = null

  // Ditto for the bytes after the put
  var bytesAfterPut: ByteBuffer = null

  // Size of the block in bytes (to return to caller)
  var size = 0L

  myInfo.synchronized {
    logTrace("Put for block " + blockId + " took " + Utils.getUsedTimeMs(startTimeMs)
      + " to get into synchronized block")

    var marked = false
    try {
      if (level.useMemory) {
        // Save it just to memory first, even if it also has useDisk set to true; we will later
        // drop it to disk if the memory store can't hold it.
        val res = memoryStore.putValues(blockId, values, level, true)
        size = res.size
        res.data match {
          case Right(newBytes) =&gt; bytesAfterPut = newBytes
          case Left(newIterator) =&gt; valuesAfterPut = newIterator
        }
      } else {
        // Save directly to disk.
        // Don't get back the bytes unless we replicate them.
        val askForBytes = level.replication &gt; 1
        val res = diskStore.putValues(blockId, values, level, askForBytes)
        size = res.size
        res.data match {
          case Right(newBytes) =&gt; bytesAfterPut = newBytes
          case _ =&gt;
        }
      }

      // Now that the block is in either the memory or disk store, let other threads read it,
      // and tell the master about it.
      marked = true
      myInfo.markReady(size)
      if (tellMaster) {
        reportBlockStatus(blockId, myInfo)
      }
    } finally {
      // If we failed at putting the block to memory/disk, notify other possible readers
      // that it has failed, and then remove it from the block info map.
      if (! marked) {
        // Note that the remove must happen before markFailure otherwise another thread
        // could've inserted a new BlockInfo before we remove it.
        blockInfo.remove(blockId)
        myInfo.markFailure()
        logWarning("Putting block " + blockId + " failed")
      }
    }
  }
  logDebug("Put block " + blockId + " locally took " + Utils.getUsedTimeMs(startTimeMs))

  // Replicate block if required
  if (level.replication &gt; 1) {
    val remoteStartTime = System.currentTimeMillis
    // Serialize the block if not already done
    if (bytesAfterPut == null) {
      if (valuesAfterPut == null) {
        throw new SparkException(
          "Underlying put returned neither an Iterator nor bytes! This shouldn't happen.")
      }
      bytesAfterPut = dataSerialize(blockId, valuesAfterPut)
    }
    replicate(blockId, bytesAfterPut, level)
    logDebug("Put block " + blockId + " remotely took " + Utils.getUsedTimeMs(remoteStartTime))
  }
  BlockManager.dispose(bytesAfterPut)

  return size
}
</code></pre></div></div>

<p>å¯¹äº<code class="language-plaintext highlighter-rouge">put()</code>æ“ä½œï¼Œä¸»è¦åˆ†ä¸ºä»¥ä¸‹3ä¸ªæ­¥éª¤ï¼š</p>

<ol>
  <li>ä¸ºblockåˆ›å»º<code class="language-plaintext highlighter-rouge">BlockInfo</code>ç»“æ„ä½“å­˜å‚¨blockç›¸å…³ä¿¡æ¯ï¼ŒåŒæ—¶å°†å…¶åŠ é”ä½¿å…¶ä¸èƒ½è¢«è®¿é—®ã€‚</li>
  <li>æ ¹æ®blockçš„storage levelå°†blockå­˜å‚¨åˆ°memoryæˆ–æ˜¯diskä¸Šï¼ŒåŒæ—¶è§£é”æ ‡è¯†è¯¥blockå·²ç»readyï¼Œå¯è¢«è®¿é—®ã€‚</li>
  <li>æ ¹æ®blockçš„replicationæ•°å†³å®šæ˜¯å¦å°†è¯¥block replicateåˆ°è¿œç«¯ã€‚</li>
</ol>

<p>æ¥ç€æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹<code class="language-plaintext highlighter-rouge">get()</code>å‡½æ•°çš„å®ç°ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def get(blockId: String): Option[Iterator[Any]] = {
  val local = getLocal(blockId)
  if (local.isDefined) {
    logInfo("Found block %s locally".format(blockId))
    return local
  }
  val remote = getRemote(blockId)
  if (remote.isDefined) {
    logInfo("Found block %s remotely".format(blockId))
    return remote
  }
  None
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">get()</code>é¦–å…ˆä¼šä»localçš„<code class="language-plaintext highlighter-rouge">BlockManager</code>ä¸­æŸ¥æ‰¾blockï¼Œå¦‚æœæ‰¾åˆ°åˆ™è¿”å›ç›¸åº”çš„blockï¼Œè‹¥localæ²¡æœ‰æ‰¾åˆ°è¯¥blockï¼Œåˆ™å‘èµ·è¯·æ±‚ä»å…¶ä»–çš„executorä¸Šçš„<code class="language-plaintext highlighter-rouge">BlockManager</code>ä¸­æŸ¥æ‰¾blockã€‚åœ¨é€šå¸¸æƒ…å†µä¸‹Sparkä»»åŠ¡çš„åˆ†é…æ˜¯æ ¹æ®blockçš„åˆ†å¸ƒå†³å®šçš„ï¼Œä»»åŠ¡å¾€å¾€ä¼šè¢«åˆ†é…åˆ°æ‹¥æœ‰blockçš„èŠ‚ç‚¹ä¸Šï¼Œå› æ­¤<code class="language-plaintext highlighter-rouge">getLocal()</code>å°±èƒ½æ‰¾åˆ°æ‰€éœ€çš„blockï¼›ä½†æ˜¯åœ¨èµ„æºæœ‰é™çš„æƒ…å†µä¸‹ï¼ŒSparkä¼šå°†ä»»åŠ¡è°ƒåº¦åˆ°ä¸blockä¸åŒçš„èŠ‚ç‚¹ä¸Šï¼Œè¿™æ ·å°±å¿…é¡»é€šè¿‡<code class="language-plaintext highlighter-rouge">getRemote()</code>æ¥è·å¾—blockã€‚</p>

<p>æˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹<code class="language-plaintext highlighter-rouge">getLocal()</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def getLocal(blockId: String): Option[Iterator[Any]] = {
  logDebug("Getting local block " + blockId)
  val info = blockInfo.get(blockId).orNull
  if (info != null) {
    info.synchronized {

      // In the another thread is writing the block, wait for it to become ready.
      if (!info.waitForReady()) {
        // If we get here, the block write failed.
        logWarning("Block " + blockId + " was marked as failure.")
        return None
      }

      val level = info.level
      logDebug("Level for block " + blockId + " is " + level)

      // Look for the block in memory
      if (level.useMemory) {
        logDebug("Getting block " + blockId + " from memory")
        memoryStore.getValues(blockId) match {
          case Some(iterator) =&gt;
            return Some(iterator)
          case None =&gt;
            logDebug("Block " + blockId + " not found in memory")
        }
      }

      // Look for block on disk, potentially loading it back into memory if required
      if (level.useDisk) {
        logDebug("Getting block " + blockId + " from disk")
        if (level.useMemory &amp;&amp; level.deserialized) {
          diskStore.getValues(blockId) match {
            case Some(iterator) =&gt;
              // Put the block back in memory before returning it
              // TODO: Consider creating a putValues that also takes in a iterator ?
              val elements = new ArrayBuffer[Any]
              elements ++= iterator
              memoryStore.putValues(blockId, elements, level, true).data match {
                case Left(iterator2) =&gt;
                  return Some(iterator2)
                case _ =&gt;
                  throw new Exception("Memory store did not return back an iterator")
              }
            case None =&gt;
              throw new Exception("Block " + blockId + " not found on disk, though it should be")
          }
        } else if (level.useMemory &amp;&amp; !level.deserialized) {
          // Read it as a byte buffer into memory first, then return it
          diskStore.getBytes(blockId) match {
            case Some(bytes) =&gt;
              // Put a copy of the block back in memory before returning it. Note that we can't
              // put the ByteBuffer returned by the disk store as that's a memory-mapped file.
              // The use of rewind assumes this.
              assert (0 == bytes.position())
              val copyForMemory = ByteBuffer.allocate(bytes.limit)
              copyForMemory.put(bytes)
              memoryStore.putBytes(blockId, copyForMemory, level)
              bytes.rewind()
              return Some(dataDeserialize(blockId, bytes))
            case None =&gt;
              throw new Exception("Block " + blockId + " not found on disk, though it should be")
          }
        } else {
          diskStore.getValues(blockId) match {
            case Some(iterator) =&gt;
              return Some(iterator)
            case None =&gt;
              throw new Exception("Block " + blockId + " not found on disk, though it should be")
          }
        }
      }
    }
  } else {
    logDebug("Block " + blockId + " not registered locally")
  }
  return None
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">getLocal()</code>é¦–å…ˆä¼šæ ¹æ®block idè·å¾—ç›¸åº”çš„<code class="language-plaintext highlighter-rouge">BlockInfo</code>å¹¶ä»ä¸­å–å‡ºè¯¥blockçš„storage levelï¼Œæ ¹æ®storage levelçš„ä¸åŒ<code class="language-plaintext highlighter-rouge">getLocal()</code>åˆè¿›å…¥ä»¥ä¸‹ä¸åŒåˆ†æ”¯ï¼š</p>

<ol>
  <li>level.useMemory == trueï¼šä»memoryä¸­å–å‡ºblockå¹¶è¿”å›ï¼Œè‹¥æ²¡æœ‰å–åˆ°åˆ™è¿›å…¥åˆ†æ”¯2ã€‚</li>
  <li>level.useDisk == true:
    <ul>
      <li>level.useMemory == true: å°†blockä»diskä¸­è¯»å‡ºå¹¶å†™å…¥å†…å­˜ä»¥ä¾¿ä¸‹æ¬¡ä½¿ç”¨æ—¶ç›´æ¥ä»å†…å­˜ä¸­è·å¾—ï¼ŒåŒæ—¶è¿”å›è¯¥blockã€‚</li>
      <li>level.useMemory == false: å°†blockä»diskä¸­è¯»å‡ºå¹¶è¿”å›</li>
    </ul>
  </li>
  <li>level.useDisk == false: æ²¡æœ‰åœ¨æœ¬åœ°æ‰¾åˆ°blockï¼Œè¿”å›Noneã€‚</li>
</ol>

<p>æ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹<code class="language-plaintext highlighter-rouge">getRemote()</code>ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def getRemote(blockId: String): Option[Iterator[Any]] = {
  if (blockId == null) {
    throw new IllegalArgumentException("Block Id is null")
  }
  logDebug("Getting remote block " + blockId)
  // Get locations of block
  val locations = master.getLocations(blockId)

  // Get block from remote locations
  for (loc &lt;- locations) {
    logDebug("Getting remote block " + blockId + " from " + loc)
    val data = BlockManagerWorker.syncGetBlock(
      GetBlock(blockId), ConnectionManagerId(loc.host, loc.port))
    if (data != null) {
      return Some(dataDeserialize(blockId, data))
    }
    logDebug("The value of block " + blockId + " is null")
  }
  logDebug("Block " + blockId + " not found")
  return None
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">getRemote()</code>é¦–å…ˆå–å¾—è¯¥blockçš„æ‰€æœ‰locationä¿¡æ¯ï¼Œç„¶åæ ¹æ®locationå‘è¿œç«¯å‘é€è¯·æ±‚è·å–blockï¼Œåªè¦æœ‰ä¸€ä¸ªè¿œç«¯è¿”å›blockè¯¥å‡½æ•°å°±è¿”å›è€Œä¸ç»§ç»­å‘é€è¯·æ±‚ã€‚</p>

<p>è‡³æ­¤æˆ‘ä»¬ç®€å•ä»‹ç»äº†<code class="language-plaintext highlighter-rouge">BlockManager</code>ç±»ä¸­çš„<code class="language-plaintext highlighter-rouge">get()</code>å’Œ<code class="language-plaintext highlighter-rouge">put()</code>å‡½æ•°ï¼Œä½¿ç”¨è¿™ä¸¤ä¸ªå‡½æ•°å¤–éƒ¨ç±»å¯ä»¥è½»æ˜“åœ°å­˜å–blockæ•°æ®ã€‚</p>

<h3 id="partitionå¦‚ä½•è½¬åŒ–ä¸ºblock">Partitionå¦‚ä½•è½¬åŒ–ä¸ºBlock</h3>

<p>åœ¨storageæ¨¡å—é‡Œé¢æ‰€æœ‰çš„æ“ä½œéƒ½æ˜¯å’Œblockç›¸å…³çš„ï¼Œä½†æ˜¯åœ¨RDDé‡Œé¢æ‰€æœ‰çš„è¿ç®—éƒ½æ˜¯åŸºäºpartitionçš„ï¼Œé‚£ä¹ˆpartitionæ˜¯å¦‚ä½•ä¸blockå¯¹åº”ä¸Šçš„å‘¢ï¼Ÿ</p>

<p>RDDè®¡ç®—çš„æ ¸å¿ƒå‡½æ•°æ˜¯<code class="language-plaintext highlighter-rouge">iterator()</code>å‡½æ•°ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>final def iterator(split: Partition, context: TaskContext): Iterator[T] = {
  if (storageLevel != StorageLevel.NONE) {
    SparkEnv.get.cacheManager.getOrCompute(this, split, context, storageLevel)
  } else {
    computeOrReadCheckpoint(split, context)
  }
}
</code></pre></div></div>

<p>å¦‚æœå½“å‰RDDçš„storage levelä¸æ˜¯NONEçš„è¯ï¼Œè¡¨ç¤ºè¯¥RDDåœ¨<code class="language-plaintext highlighter-rouge">BlockManager</code>ä¸­æœ‰å­˜å‚¨ï¼Œé‚£ä¹ˆè°ƒç”¨<code class="language-plaintext highlighter-rouge">CacheManager</code>ä¸­çš„<code class="language-plaintext highlighter-rouge">getOrCompute()</code>å‡½æ•°è®¡ç®—RDDï¼Œåœ¨è¿™ä¸ªå‡½æ•°ä¸­partitionå’Œblockå‘ç”Ÿäº†å…³ç³»ï¼š</p>

<p>é¦–å…ˆæ ¹æ®RDD idå’Œpartition indexæ„é€ å‡ºblock id (rdd_xx_xx)ï¼Œæ¥ç€ä»<code class="language-plaintext highlighter-rouge">BlockManager</code>ä¸­å–å‡ºç›¸åº”çš„blockã€‚</p>

<ul>
  <li>å¦‚æœè¯¥blockå­˜åœ¨ï¼Œè¡¨ç¤ºæ­¤RDDåœ¨ä¹‹å‰å·²ç»è¢«è®¡ç®—è¿‡å’Œå­˜å‚¨åœ¨<code class="language-plaintext highlighter-rouge">BlockManager</code>ä¸­ï¼Œå› æ­¤å–å‡ºå³å¯ï¼Œæ— éœ€å†é‡æ–°è®¡ç®—ã€‚</li>
  <li>å¦‚æœè¯¥blockä¸å­˜åœ¨åˆ™éœ€è¦è°ƒç”¨RDDçš„<code class="language-plaintext highlighter-rouge">computeOrReadCheckpoint()</code>å‡½æ•°è®¡ç®—å‡ºæ–°çš„blockï¼Œå¹¶å°†å…¶å­˜å‚¨åˆ°<code class="language-plaintext highlighter-rouge">BlockManager</code>ä¸­ã€‚</li>
</ul>

<p>éœ€è¦æ³¨æ„çš„æ˜¯blockçš„è®¡ç®—å’Œå­˜å‚¨æ˜¯é˜»å¡çš„ï¼Œè‹¥å¦ä¸€çº¿ç¨‹ä¹Ÿéœ€è¦ç”¨åˆ°æ­¤blockåˆ™éœ€ç­‰åˆ°è¯¥çº¿ç¨‹blockçš„loadingç»“æŸã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def getOrCompute[T](rdd: RDD[T], split: Partition, context: TaskContext, storageLevel: StorageLevel)
    : Iterator[T] = {
  val key = "rdd_%d_%d".format(rdd.id, split.index)
  logDebug("Looking for partition " + key)
  blockManager.get(key) match {
    case Some(values) =&gt;
      // Partition is already materialized, so just return its values
      return values.asInstanceOf[Iterator[T]]

    case None =&gt;
      // Mark the split as loading (unless someone else marks it first)
      loading.synchronized {
        if (loading.contains(key)) {
          logInfo("Another thread is loading %s, waiting for it to finish...".format (key))
          while (loading.contains(key)) {
            try {loading.wait()} catch {case _ : Throwable =&gt;}
          }
          logInfo("Finished waiting for %s".format(key))
          // See whether someone else has successfully loaded it. The main way this would fail
          // is for the RDD-level cache eviction policy if someone else has loaded the same RDD
          // partition but we didn't want to make space for it. However, that case is unlikely
          // because it's unlikely that two threads would work on the same RDD partition. One
          // downside of the current code is that threads wait serially if this does happen.
          blockManager.get(key) match {
            case Some(values) =&gt;
              return values.asInstanceOf[Iterator[T]]
            case None =&gt;
              logInfo("Whoever was loading %s failed; we'll try it ourselves".format  (key))
              loading.add(key)
          }
        } else {
          loading.add(key)
        }
      }
      try {
        // If we got here, we have to load the split
        logInfo("Partition %s not found, computing it".format(key))
        val computedValues = rdd.computeOrReadCheckpoint(split, context)
        // Persist the result, so long as the task is not running locally
        if (context.runningLocally) { return computedValues }
        val elements = new ArrayBuffer[Any]
        elements ++= computedValues
        blockManager.put(key, elements, storageLevel, true)
        return elements.iterator.asInstanceOf[Iterator[T]]
      } finally {
        loading.synchronized {
          loading.remove(key)
          loading.notifyAll()
        }
      }
  }
}
</code></pre></div></div>

<p>è¿™æ ·RDDçš„transformationã€actionå°±å’Œblockæ•°æ®å»ºç«‹äº†è”ç³»ï¼Œè™½ç„¶æŠ½è±¡ä¸Šæˆ‘ä»¬çš„æ“ä½œæ˜¯åœ¨partitionå±‚é¢ä¸Šè¿›è¡Œçš„ï¼Œä½†æ˜¯partitionæœ€ç»ˆè¿˜æ˜¯è¢«æ˜ å°„æˆä¸ºblockï¼Œå› æ­¤å®é™…ä¸Šæˆ‘ä»¬çš„æ‰€æœ‰æ“ä½œéƒ½æ˜¯å¯¹blockçš„å¤„ç†å’Œå­˜å–ã€‚</p>

<h2 id="end">End</h2>

<p>æœ¬æ–‡å°±storageæ¨¡å—çš„ä¸¤ä¸ªå±‚é¢è¿›è¡Œäº†ä»‹ç»-é€šä¿¡å±‚å’Œå­˜å‚¨å±‚ã€‚é€šä¿¡å±‚ä¸­ç®€å•ä»‹ç»äº†ç±»ç»“æ„å’Œç»„æˆä»¥åŠç±»åœ¨é€šä¿¡å±‚ä¸­æ‰€æ‰®æ¼”çš„ä¸åŒè§’è‰²ï¼Œè¿˜æœ‰ä¸åŒè§’è‰²ä¹‹é—´é€šä¿¡çš„æŠ¥æ–‡ï¼ŒåŒæ—¶ç®€å•ä»‹ç»äº†é€šä¿¡å±‚çš„å¯åŠ¨å’Œæ³¨å†Œç»†èŠ‚ã€‚å­˜å‚¨å±‚ä¸­åˆ†åˆ«ä»‹ç»äº†<code class="language-plaintext highlighter-rouge">DiskStore</code>å’Œ<code class="language-plaintext highlighter-rouge">MemoryStore</code>ä¸­å¯¹äºblockçš„å­˜å’Œå–çš„å®ç°ä»£ç ï¼ŒåŒæ—¶åˆ†æäº†<code class="language-plaintext highlighter-rouge">BlockManager</code>ä¸­<code class="language-plaintext highlighter-rouge">put()</code>å’Œ<code class="language-plaintext highlighter-rouge">get()</code>æ¥å£ï¼Œæœ€åç®€å•ä»‹ç»äº†Spark RDDä¸­çš„partitionä¸<code class="language-plaintext highlighter-rouge">BlockManager</code>ä¸­çš„blockä¹‹é—´çš„å…³ç³»ï¼Œä»¥åŠå¦‚ä½•äº¤äº’å­˜å–blockçš„ã€‚</p>

<p>æœ¬æ–‡ä»æ•´ä½“ä¸Šåˆ†æäº†storageæ¨¡å—çš„å®ç°ï¼Œå¹¶æœªå°±å…·ä½“å®ç°åšéå¸¸ç»†èŠ‚çš„åˆ†æï¼Œç›¸ä¿¡åœ¨çœ‹å®Œæœ¬æ–‡å¯¹storageæ¨¡å—æœ‰ä¸€ä¸ªæ•´ä½“çš„å°è±¡ä»¥åå†å»åˆ†æç»†èŠ‚çš„å®ç°ä¼šæœ‰äº‹åŠåŠŸå€çš„æ•ˆæœã€‚</p>
:ET